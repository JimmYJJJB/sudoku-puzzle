Daniel Jasek Report.txt

From the user's persective, this program asks the user for a size of a sudoku board and then asks for an input file. When these are given, the program first displays the unsolved board, and then displays the solved board.

The backbone of the program is the Puzzle class. This class contains 2-d vectors for the board, a 2-d vector for the original board, as well as a 3-d vector to store the move possibilities for each board space. Many of the methods in this class were already discussed in the lab5 report. This new Puzzle class also contains public methods AIscan() and singleton(), which are two methods for solving a Sudoku board.

One new function in this lab is the findSearchRowOrCol() which takes in an int as an argument, and returns a 0, 3, or 6, which represents the starting row or column for the mini-grid scanner. The print3D() function loops through the 3d vector and displays it in a readable fashion. This is useful for debugging. The findPossibilities() function loops through each entry in the board, and checks for a repeat of that number in the same row, column, or mini-grid, placing a 0 in the 3rd dimension of scanBoard if so, and leaving the 1 that is already present if not. This leaves a 3d vector that contains 9 entries for each possible board space - a 0 means that an entry of that index cannot be placed there, and a 1 means it can. The main.cpp file instantiates an integer puzzle and then displays the board, runs the AIscan() and singleton() algorithms on it, and then displays the solved puzzle.

This program works correctly. It has been tested with the easy, medium, and hard puzzles from class, and successfully solved all of them, ending the puzzle with no repeats in a row, column, or grid, and getting the same results as another online solver.

The AIscan() method loops through the entire board 500 times (to be safe, although this is probably not necessary), and checks if a 3rd dimension vector entry has only one 1 in it. If it does, the board is updated to the proper number, and findPossibilities() is called again. The singleton() method loops through the entire board while the board is not full, and loops through each number possibility in each space. If the space is empty and a certain number entry is valid, the algorithm checks each other move possibilities vector in the same row, column, and minigrid, and if any of these do not contain a duplicate of the same valid move, this move is made. Three variables are used, rowUnique, colUnique, and miniGridUnique, to track this. Each are initially set to true, and if a duplicate is found, they are set to false. This algorithm also calls the findPossibilities() method after each successful move to gauge the current state of the board more accurately. In terms of what went well, the print3D() method was very useful for checking out the 3d vector and debugging code. Once the algorithms were in place with the medium puzzle, they worked almost immediately the hard puzzle as well. Dealing with the nested for loops was difficult though, and there are probably parts of my code that I could have reused more than I did. In general, this lab was one of the most challenging, but definitely the most rewarding, as a Sudoku solver is a decently complicated algorithm to implement. 

===========================================================
I would like my code to be run on the hard problems as well.

