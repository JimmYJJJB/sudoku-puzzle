Report for Lab 5 - Daniel Jasek

From the user's perspective, this program (main.cpp) implements an interactive Sudoku player. It asks the player for the size of the board and an input file. It then displays the board and asks the user to enter the coordinates and new value of a spot to update. If a coordinate is either not on the board or is a entry that was non-zero to start the game, an error message is displayed, and the user is asked to pick a new spot on the board. Once the user enters a value to update this new spot with, an algorithm checks if this move is a valid Sudoku move (no repeats in the row, column, or mini-grid). If all of these conditions are satisfied, the board is updated. Once the user fills up the entire board with valid moves, a congratulatory message is displayed and the program ends.

The program has a driver program, main.cpp, that creates an integer puzzle and calls the play() method. Everything else is controlled by the puzzle.h file, which contains the interface and the implementation for the program as a templated class. Puzzle contains two 2-d vectors - one for the current board, and one for the original board. It also has data members for the size of the board, and the current row, column, and entry. The constructor prompts the user to enter the size of the board and the name of the file, and then reads in each entry in the file into a 2-d vector which serves as the board. The constructor also creates a copy of the original board for later use. The display() method loops through each element in the vector and displays the board, complete with dividing lines for more viewability. getMove() promts the user for the row, column, and value of their entry - ensuring that the coordinates are valid ones by calling the areCoordinatesValid() method. This method checks if the entry is both on the board and not overriding any value that was there to start the game - by referencing the vector that represents the original board. updateBoard() updates the current vector location with the appropriate entry as defined previously by the user. isValidEntry() is used to check if a move is a valid Sudoku move, by looping through the row, column, and minigrid to check for a duplicate entry. The hasWon() method checks if the board is full, and then returns 1 if true, meaning the game is over. And lastly, the play() method uses all the previously defined methods to create a gameplay experience for the user.

The program was verified by testing each method individually during the development process and testing how they all integrated together in the finished product. The functions that check for valid moves correctly identify cases where the move is invalid, and the user does get prompted to enter another move. The board is also correctly updated after each valid move. The hasWon() method also works nicely by ending the game with an appropriate message when the board is full, but no sooner.

Overall, the parts of this program that worked well were the display(), isValidEntry(), and hasWon() functions. The copy of the orignal board made the hasWon() function very easy to implement and worked almost immediately. getMove(), areCoordinatesValid(), and updateBoard() were slightly tougher to implement, especially because I did not realize for a while that I was working with chars as my templated type instead of ints. The program as a whole was easier to implement than blackjack, because there were less extraneous things to keep track of, and the gameplay was simpler. The fact that the game was known to be over simply when the board was full was a nice fact to use, since the game tracked whether each move was valid or not as it was being made. Making the current row, column, and entry private data members available to the entire class also made the implementation easy, because these things did not have to be passed around as parameters. The part of isValidEntry() that checked for repeats in the mini-grid was probably the hardest algorithm to implement. It worked by finding the correct starting row and column (0, 3, or 6), and then using a nested for loop to check in 3 steps in each row and column for a repeat. 
